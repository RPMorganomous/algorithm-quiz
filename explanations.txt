Q1)  I wanted to make this a simple as possible, so I check each letter in t against s and build a string of all matching characters.  I can avoid any further computations if I find there are not at least 2 matching characters.  I used the permutations function of the itertools library to create all possible permutations of the new string because it's really efficent with memory and speed.  Still, assuming that our positive test case must include all the letters in order to be a true anagram, it takes O(n!) time to do that.  Next I check to see if any of the permutations exist in s and return the result = O(n(s*t)).

Q2)  A palindrome could be of two types, even or odd number of characters, so I will check for both cases beginning with the first 3 characters.  If the middle character is surrounded by matching characters, then I will check the next set of outlying characters.  Next I will repeat this procedure but starting with 4 letters.  This means I will be scanning the complete string twice for a O(2n) efficency.

Q3)  To program the MST using Kruskal's algorithm: first, order the edges by value, then, beginning with the lowest value edge, add edges to the graph until the vertices total is nodes -1, taking care to avoid closing loops among vertices by adding them into two sets and joining the sets when edges contain vertices from both sets.  This results in a O(ElogV) efficiency to iterate through all edges and check for unions.

Q4)  The matrix is not a standard Adjacency Matrix, but it's easy to read beginning with the root node and tracing the tree from there.  Once the tree is built, it's just a matter of comparing nodes recursivly and isolating the least common ancestor.  This method results in a maximum of O(2n) efficiency because the matrix is sorted once and the tree is traversed once. 

Q5)  Assuming a simple linked list is provided, all I have to do is count the items in the list, subtract the given amount and then step to that item in the list.  Efficiency of this solution is (O2n) because I once count the list and then once traverse it.