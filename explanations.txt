Q1)  I do a character count of t, and then compare that to character count slices of matching length in s.  If the character counts match, there is an anagram and I return True.  Time complexity is O(len(s)) and space complexity is O(1).

Q2)  A palindrome could be of two types, even or odd number of characters, so I will check for both cases beginning with the first 3 characters.  If the middle character is surrounded by matching characters, then I will check the next set of outlying characters.  Next I will repeat this procedure but starting with 4 letters.  This means I will be scanning the complete string twice for a O(2n) efficency.  Space efficiency will be O(1) because it will be the size of the input string.

Q3)  To program the MST using Kruskal's algorithm: first, order the edges by value, then, beginning with the lowest value edge, add edges to the graph until the vertices total is nodes -1, taking care to avoid closing loops among vertices by adding them into two sets and joining the sets when edges contain vertices from both sets.  This results in a O(ElogV) efficiency to iterate through all edges and check for unions. Space efficiency will be O(n) for the tree.

Q4)  The matrix is not a standard Adjacency Matrix, but it's easy to read beginning with the root node and traverse the matrix from there without building a BST.  If the root is greater than the max of n1, n2: check recursively using minimum value of the nodes found.  If the root is less than the min of n1, n2: check recursively using maximum value of the nodes found.  This method results in a maximum of O(n) time efficiency because the matrix is is traversed once and a space efficiency of only O(1) because I'm not creating any data structure. 

Q5)  Assuming a simple linked list is provided, all I have to do is count the items in the list, subtract the given amount and then step to that item in the list.  Efficiency of this solution is (O2n) because I once count the list and then once traverse it.  Space efficiency will be O(n) because the array scales with the size of the input.