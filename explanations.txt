Q1)  I wanted to make this a simple as possible, so I check each letter in t against s and build a string of all matching characters.  I can avoid any further computations if I find there are not at least 2 matching characters.  I used the permutations function of the itertools library to create all possible permutations of the new string because it's really efficent with memory and speed.  Still, assuming that our positive test case must include all the letters in order to be a true anagram, it takes O(n!) time to do that.  Next I check to see if any of the permutations exist in s and return the result = O(n(s*t)).

Q2)  A palindrome could be of two types, even or odd number of characters, so I will check for both cases beginning with the first 3 characters.  If the middle character is surrounded by matching characters, then I will check the next set of outlying characters.  Next I will repeat this procedure but starting with 4 letters.  This means I will be scanning the complete string twice for a O(2n) efficency.